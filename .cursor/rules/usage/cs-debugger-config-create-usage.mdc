---
description: Creating Debugger Configurations
globs: Source/Debugger/Configs/**
alwaysApply: false
---
# Creating Debugger Configurations

This document describes how to create custom configurations for the Press-R Debugger module, allowing you to monitor specific values during gameplay.

## The `IDebuggerConfig` Interface

All debugger configurations must implement the `IDebuggerConfig` interface found in `[IDebuggerConfig.cs](mdc:Source/Debugger/IDebuggerConfig.cs)`. This interface defines the behavior and the data points for a specific debugging session.

### Interface Members

*   **`string Name { get; }`**: A user-friendly name for the configuration, displayed in the debugger window's dropdown menu.
*   **`float UpdateInterval { get; }`**: The desired time interval (in seconds) between taking value snapshots while recording. A smaller value means more frequent updates but potentially more data.
*   **`float StartDelaySeconds { get; }`**: An optional delay (in seconds) before the debugger starts recording after the "Start" button is pressed. Useful if you need to wait for certain game states to initialize. Use `0f` for no delay.
*   **`IEnumerable<DebuggerTrackedValueInfo> GetTrackedValues()`**: The core method where you define *which* values to track and *how* they should be displayed. This method returns a list of `DebuggerTrackedValueInfo` objects.

## Defining Tracked Values (`GetTrackedValues`)

The `GetTrackedValues` method returns a list of `DebuggerTrackedValueInfo` objects. Each object represents one data point to be monitored.

The recommended way to create these objects is by using the static factory methods provided by the `DebuggerTrackedValueInfo` class. It's highly recommended to add the following using directive to your config file for brevity:

```csharp
using static PressR.Debugger.DebuggerTrackedValueInfo;
```

### API for Creating `DebuggerTrackedValueInfo`

The API uses a combination of static factory methods (to define the *primary intent*) and a fluent interface (to *refine* collection display). See `[DebuggerTrackedValueInfo.cs](mdc:Source/Debugger/DebuggerTrackedValueInfo.cs)` for the implementation details.

1.  **`TrackValue(string path, string displayName = null)`**:
    *   **Purpose**: Tracks a simple value (primitive, struct, or object) and displays its `ToString()` representation.
    *   **Example**:
        ```csharp
        TrackValue("Find.TickManager.TicksGame", "Ticks Game")
        ```

2.  **`TrackCollectionCount(string path, string displayName = null)`**:
    *   **Purpose**: Tracks a collection (`ICollection` or `IDictionary`) and displays only the number of elements/pairs it contains.
    *   **Example**:
        ```csharp
        TrackCollectionCount("Find.CurrentMap.mapPawns.AllPawns", "Map Pawns (Count Only)")
        ```

3.  **`TrackCollectionItems(string path, string displayName = null)`**:
    *   **Purpose**: Tracks a collection (`ICollection`, like `List<T>`, `T[]`) and displays its items. Returns a configurator object to refine display options.
    *   **Refinement Methods**:
        *   `.WithLimit(int limit)`: Show only the first `limit` items.
        *   `.ShowAll()`: Show all items in the collection (no limit).
        *   *(Default)*: If neither `.WithLimit()` nor `.ShowAll()` is called, shows the default number of items (currently 3).
    *   **Examples**:
        ```csharp
        // Show first 5 items
        TrackCollectionItems("Find.CurrentMap.listerThings.AllThings", "All Things (<=5)")
            .WithLimit(5)

        // Show all items
        TrackCollectionItems("Find.Selector.SelectedObjectsListForReading", "Selected Items (all)")
            .ShowAll()

        // Show default number of items (e.g., 3)
        TrackCollectionItems("SomeList.Items", "Some Items (Default Limit)")
        ```
    *   **Tracking Dictionary Values**: To track only the *values* of a dictionary, access its `.Values` property in the path:
        ```csharp
        // Show all IGraphicObject values from the dictionary
        TrackCollectionItems(
            "PressR.PressRMain._graphicsManager._graphicObjects.Values",
            "Graphic Objects (Values Only)"
        ).ShowAll()
        ```

4.  **`TrackDictionaryKeys(string path, string displayName = null)`**:
    *   **Purpose**: Tracks a dictionary (`IDictionary`) and displays its keys. Returns a configurator object to refine display options.
    *   **Refinement Methods**:
        *   `.WithLimit(int limit)`: Show only the first `limit` keys.
        *   `.ShowAll()`: Show all keys in the dictionary (no limit).
        *   *(Default)*: If neither `.WithLimit()` nor `.ShowAll()` is called, shows the default number of keys (currently 3).
    *   **Examples**:
        ```csharp
        // Show first 5 keys
        TrackDictionaryKeys("Find.World.worldObjects.AllWorldObjects", "World Objects Keys (<=5)")
            .WithLimit(5)

        // Show all keys
        TrackDictionaryKeys("SomeDictionary.Data", "All Dict Keys")
            .ShowAll()

        // Show default number of keys (e.g., 3)
        TrackDictionaryKeys("AnotherDictionary.Map", "Dict Keys (Default Limit)")
        ```

### Value Path Syntax

The `path` parameter in the factory methods specifies how the debugger should find the value to track. It uses a dot-separated string to navigate through static classes, instance members (fields and properties).

*   **Standard Paths**: `Find.CurrentMap.mapPawns.AllPawns`
*   **Static Members**: `UnityEngine.Time.time`
*   **Type Names (Limited Scope)**: `TickManager.TicksGame` (works for common namespaces like `Verse`, `RimWorld`, `UnityEngine`, etc.)
*   **Assembly Qualified Names (AQN)**: `Namespace.TypeName, AssemblyName.StaticMember.InstanceMember` (rarely needed)
*   **Accessing Dictionary Values/Keys**: Use `.Values` or `.Keys` properties: `MyObject.MyDictionary.Values`

**Unsupported**: Indexers (`[]`), method calls (`()`), conditional access (`?.`).

For detailed examples and known entry points (`Find`, `Current`, `Game`), refer to the `ValuePathSyntax` static helper class within `[DebuggerTrackedValueInfo.cs](mdc:Source/Debugger/DebuggerTrackedValueInfo.cs)`. You can also view this help text in-game by clicking the info (`i`) button in the debugger window.

## Examples

Refer to the existing configuration files for practical examples:

*   `[ExampleConfig.cs](mdc:Source/Debugger/Configs/ExampleConfig.cs)`: Demonstrates various tracking types.
*   `[GraphicsManagerConfig.cs](mdc:Source/Debugger/Configs/GraphicsManagerConfig.cs)`: Shows tracking of internal mod state.

## Discovery

All classes implementing `IDebuggerConfig` within the same assembly as the debugger core (`PressR.dll`) are automatically discovered at startup and made available in the debugger window's dropdown menu. Simply create your class, implement the interface, and it should appear next time you open the debugger window in-game (after recompiling).
