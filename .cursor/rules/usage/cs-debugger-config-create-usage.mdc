---
description: Creating Debugger Configurations
globs: Source/Debugger/Configs/**
alwaysApply: false
---
# Creating Debugger Configurations

This document outlines the process for creating custom configurations for the Press-R Debugger module. These configurations allow developers to monitor specific game or mod values during runtime.

## Core Concept: The `IDebuggerConfig` Interface

Every debugger configuration must implement the `IDebuggerConfig` interface, located in `Source/Debugger/IDebuggerConfig.cs`. This interface serves as the contract for defining a specific debugging profile.

### Interface Definition

```csharp
public interface IDebuggerConfig
{
    // A user-friendly name displayed in the debugger UI.
    string Name { get; }

    // The time interval (seconds) between value snapshots during recording.
    // Smaller values increase frequency but generate more data.
    float UpdateInterval { get; }

    // Optional delay (seconds) before recording starts after activation.
    // Useful for waiting for game state initialization. Use 0f for no delay.
    float StartDelaySeconds { get; }

    // Defines the values to track and their display format.
    IEnumerable<DebuggerTrackedValueInfo> GetTrackedValues();
}
```

## Defining Tracked Values: `GetTrackedValues()`

The `GetTrackedValues()` method is central to a configuration. It returns a collection of `DebuggerTrackedValueInfo` objects, each representing a single data point to monitor.

**Recommendation:** Use the static factory methods provided by `DebuggerTrackedValueInfo` for creating these objects. Add the following `using` directive for cleaner code:

```csharp
using static PressR.Debugger.DebuggerTrackedValueInfo;
```

### Tracking API (`DebuggerTrackedValueInfo`)

The API utilizes static factory methods to specify the primary tracking goal, combined with a fluent interface for refining how collections are displayed. Refer to `Source/Debugger/DebuggerTrackedValueInfo.cs` for full implementation details.

1.  **`TrackValue(string path, string displayName = null)`**
    *   **Purpose**: Monitor a single value (primitive, struct, object) and display its `ToString()` representation.
    *   **Example**:
        ```csharp
        TrackValue("Find.TickManager.TicksGame", "Game Ticks")
        ```

2.  **`TrackCollectionCount(string path, string displayName = null)`**
    *   **Purpose**: Monitor a collection (`ICollection` or `IDictionary`) and display only its element count.
    *   **Example**:
        ```csharp
        TrackCollectionCount("Find.CurrentMap.mapPawns.AllPawns", "Map Pawns Count")
        ```

3.  **`TrackCollectionItems(string path, string displayName = null)`**
    *   **Purpose**: Monitor an `ICollection` (e.g., `List<T>`, `T[]`) and display its items. Returns a configurator for display options.
    *   **Refinement Methods**:
        *   `.WithLimit(int limit)`: Display up to `limit` items.
        *   `.ShowAll()`: Display all items.
        *   *(Default)*: Displays a default number of items (e.g., 3) if no refinement method is called.
    *   **Examples**:
        ```csharp
        // Display first 5 items
        TrackCollectionItems("Find.CurrentMap.listerThings.AllThings", "All Things (<=5)")
            .WithLimit(5);

        // Display all selected objects
        TrackCollectionItems("Find.Selector.SelectedObjectsListForReading", "Selected (All)")
            .ShowAll();

        // Display default number of items
        TrackCollectionItems("SomeComponent.InternalList", "Internal List (Default)");
        ```
    *   **Tracking Dictionary Values**: Access the `.Values` property in the path.
        ```csharp
        // Display all IGraphicObject values
        TrackCollectionItems("PressR.PressRMain._graphicsManager._graphicObjects.Values", "Graphic Objects (Values)")
            .ShowAll();
        ```

4.  **`TrackDictionaryKeys(string path, string displayName = null)`**
    *   **Purpose**: Monitor an `IDictionary` and display its keys. Returns a configurator for display options.
    *   **Refinement Methods**:
        *   `.WithLimit(int limit)`: Display up to `limit` keys.
        *   `.ShowAll()`: Display all keys.
        *   *(Default)*: Displays a default number of keys (e.g., 3) if no refinement method is called.
    *   **Examples**:
        ```csharp
        // Display first 10 world object keys
        TrackDictionaryKeys("Find.World.worldObjects.AllWorldObjects", "World Objects Keys (<=10)")
            .WithLimit(10);

        // Display all dictionary keys
        TrackDictionaryKeys("SomeManager.DataCache", "Cache Keys (All)")
            .ShowAll();
        ```

### Value Path Syntax

The `path` parameter uses a dot-separated string to navigate through static classes and instance members (fields, properties) to locate the target value.

*   **Standard Navigation**: `Find.CurrentMap.mapPawns.AllPawns`
*   **Static Members**: `UnityEngine.Time.time`, `Verse.Prefs.DevMode`
*   **Type Name Resolution (Limited Scope)**: `TickManager.TicksGame` (resolves common game/engine namespaces)
*   **Assembly Qualified Names (AQN)**: `Namespace.TypeName, AssemblyName.StaticMember...` (rarely required)
*   **Dictionary Access**: Use `.Values` or `.Keys` (e.g., `MyObject.MyDictionary.Values`)

**Unsupported Features**: Indexers (`[]`), method calls (`()`), conditional access (`?.`).

Refer to the `ValuePathSyntax` helper class within `Source/Debugger/DebuggerTrackedValueInfo.cs` or the in-game help (`i` button) for more details and common entry points (`Find`, `Current`, `Game`).

**Limitations (To Be Addressed):**

1.  **`GetTargetTypeName()` Ignored for Path Resolution:** The `ValueResolver` currently does not use `IDebuggerConfig.GetTargetTypeName()` to establish a starting instance for relative paths.
2.  **Relative Instance Paths Not Supported:** Paths like `"_myField"` or `"MyProperty"` (intended to resolve against a target instance) will fail, as the resolver attempts to find a global type with that name. This results in errors like "Could not resolve type from 'YourMemberName'".
3.  **Workaround:** Paths **must** start from a known static entry point (e.g., `Find`, `Current`, `PressR.PressRMain.Instance`) and navigate down to the desired instance member.
    *   Example: `"Find.CurrentMap.GetComponent<YourMapComponent>().YourField"`
    *   Example: `"PressR.PressRMain.Instance.GetFeature<MyFeature>().SomeState"`

**Future Improvements:**

*   The `ValueResolver` will be enhanced to utilize `GetTargetTypeName()`, enabling simpler, instance-relative path definitions in configurations.
